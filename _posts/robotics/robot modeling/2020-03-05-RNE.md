---
title: "Recursive Newton-Euler Formulation"
categories:
  - robotics
  - robot-modeling
tags:
  - modeling
  - dynamics
---
# test
<img src="assets/images/equ_02.JPG">  

[equ_02](assets/images/equ_02.JPG)  

[equ_02](https://github.com/MovableBro/Robotics/blob/master/assets/images/equ_02.jpg)  

![equ_02](assets/images/equ_02.JPG)  


<img src="https://github.com/MovableBro/Robotics/blob/master/assets/images/equ_02.jpg?raw=true">  

![equ_02](https://github.com/MovableBro/Robotics/blob/master/assets/images/equ_02.jpg)  

![equ_02](https://github.com/MovableBro/Robotics/blob/master/assets/images/equ_02.JPG)  



#RNE를 활용한 로봇 동역학 모델 생성
## 개요
로봇 동역학 모델링을 위한 방법론으로 Recursive Newton Euler 방법이 있다.  
순차적으로 Forward 하게 1축 부터시작해서 말단축 까지 로봇 조인트의 각속도, 각가속도 등을 구해간 뒤,  
역순으로 Backward 하게 말단축에서 시작해서 1축까지 로봇 관절 토크를 계산해 내는 과정이다.
이렇게 구한 모터 토크 방정식이 동역학 모델이 된다.

## 방법론
앞서 말했듯이, 순차적으로 Forward 하게 모션관련 파라미터를 계산한뒤, Backward 하게 힘/토크를 계산한다.

### Forward Equation
- 블록다이어그램

### Backward Equation
- 블록다이어그램

## Code Example
매트랩 코드로 예제 코드를 작성해 보았다.



# 참조
목표 : 각 조인트에 걸리는 외력힘/외력토크를 구하는 것
방법(역순으로 설명)
1.	모터가 조인트의 축에 인가하는 힘(알고 싶은 것, ti)은 링크에 걸리는 외력토크(ni)와 다음의 관계를 갖는다.
![equ_01](https://github.com/MovableBro/Robotics/blob/master/assets/images/RNE/equ_01.jpg)
2.	Backward calculation 을 통해 fi 와 ni 가 구해진다.
i = k (마지막 링크부터 계산) 
![fig_01](https://github.com/MovableBro/Robotics/blob/master/assets/images/RNE/fig_01.jpg)  
(말단에 가까운 링크의 힘, 모멘트 값으로 베이스에 가까운 인접 링크의 힘, 모멘트 값을 구함)  
fk+1=0, nk+1=0  k+1 은 링크가 없는 허공, 인가되는 외력이 없음. (로봇 말단이 어떤 곳에 접촉할 때는?)  
![equ_02](assets/images/RNE/equ_02.jpg) 
  k = 링크 번호
-	식 7, 8 
![equ_03](https://github.com/MovableBro/Robotics/blob/master/assets/images/RNE/equ_03.jpg) 
![equ_04](https://github.com/MovableBro/Robotics/blob/master/assets/images/RNE/equ_04.jpg)  
 
-	식 7, 8 에 대한 자유물체도
![fig_02](https://github.com/MovableBro/Robotics/blob/master/assets/images/RNE/fig_02.jpg) 
 
-	식 7, 8 의 유도  
뉴턴방정식과 오일러 방정식을 링크 i 에 대해 대입한다.  
뉴턴 방정식을 대입할 경우
![equ_05](https://github.com/MovableBro/Robotics/blob/master/assets/images/RNE/equ_05.jpg)  
 
오일러 방정식을 대입할 경우
![equ_06](https://github.com/MovableBro/Robotics/blob/master/assets/images/RNE/equ_06.jpg) 
 
3.	그런데, ni 와 fi 를 구하려면 각속도, 가속도 등을 구해야 한다. 
![equ_07](https://github.com/MovableBro/Robotics/blob/master/assets/images/RNE/equ_07.jpg) 

-	위 정보들을 구하기 위해서는, forward equation을 풀어야 한다.
베이스에 가까운 링크 (i=0) 부터 계산한다.
i=0 일 때는 모두 0이다. 
![fig_03](https://github.com/MovableBro/Robotics/blob/master/assets/images/RNE/fig_03.jpg)  

-	링크 i-1 및 링크 i 의 자유물체도와 식 1,2,3,4 의 유도
 
	식 1 
  
 링크 i 의 (링크 i-1 에 대한) 상대속도  링크 i-1에서 본 링크 i의 속도
 
	식 2  식 1을 미분 

![equ_08](https://github.com/MovableBro/Robotics/blob/master/assets/images/RNE/equ_08.jpg) 

	식 3
상대속도식 전개
	식 4, 5    
![equ_09](https://github.com/MovableBro/Robotics/blob/master/assets/images/RNE/equ_09.jpg) 

# 예제
예제 : 6자유도 로봇 동역학 모델 구하기
대상 : 산업용 6자유도 로봇
기구학 파라미터
-	DH 파라미터
동역학 파라미터
-	관성정보
-	링크의 질량중심
-	링크의 질량

## Matlab 코드
```matlab
clc; clear; close all;
D2R = pi/180.0; R2D = 180.0/pi;
%% 준비단계 : 로봇 기구학 모델 -> 필요한 정보 얻기
% 모델 : 로보티즈, MANIPULATOR-H
alpha1 = 0.0;   a1 = 0.0;                   d1 = 0.159; offset1 = 0.0;
alpha2 = -pi/2; a2 = 0.0;                   d2 = 0.0;   offset2 = -atan2(264, 30);
alpha3 = 0.0;   a3 = sqrt(0.264^2 + 0.03^2);d3 = 0.0;   offset3 = atan2(264, 30);
alpha4 = pi/2;  a4 = -0.03;                 d4 = 0.258; offset4 = 0.0;
alpha5 = -pi/2; a5 = 0.0;                   d5 = 0.0;   offset5 = 0.0;
alpha6 = pi/2;  a6 = 0.0;                   d6 = 0.123; offset6 = 0.0;

art1 = SerialLink([
    RevoluteMDH('alpha', alpha1, 'a', a1, 'd', d1, 'offset', offset1)
    RevoluteMDH('alpha', alpha2, 'a', a2, 'd', d2, 'offset', offset2)
    RevoluteMDH('alpha', alpha3, 'a', a3, 'd', d3, 'offset', offset3)
    RevoluteMDH('alpha', alpha4, 'a', a4, 'd', d4, 'offset', offset4)
    RevoluteMDH('alpha', alpha5, 'a', a5, 'd', d5, 'offset', offset5)
    RevoluteMDH('alpha', alpha6, 'a', a6, 'd', d6, 'offset', offset6)
    ], 'name', 'mdhART1');

%% 
q1i = 0.0*D2R;
q2i = 0.0*D2R;
q3i = -90.0*D2R;
q4i = 0.0*D2R;
q5i = -90.0*D2R;
q6i = 0.0*D2R;
qi = [q1i q2i q3i q4i q5i q6i];

q1f = 10.0*D2R;
q2f = 0.0*D2R;
q3f = -60.0*D2R;
q4f = 0.0*D2R;
q5f = -80.0*D2R;
q6f = 60.0*D2R;
qf = [q1f q2f q3f q4f q5f q6f];

figure(1), art1.plot(qi, 'noarrow'); hold on;
Ti = art1.fkine(qi);
Tf = art1.fkine(qf);

%% 궤적 생성
step = 100;
S = ctraj(Ti, Tf, step);
[q qdot q2dot] = jtraj(qi, qf, 100);

q = q';
qdot = qdot';
q2dot = q2dot';

%% 로봇 상수
% 링크 질량
m = [1030; 1404; 1236; 491; 454];     

% 질량중심
mc = []; 
mc(:, 1) = [0 1 -1.1]'; 
mc(:, 2) = [17.9 0.3 206.9]';
mc(:, 3) = [ 0.2 0.3 387.9]'; 
mc(:, 4) = [0 -1.5 514.3]'; 
mc(:, 5) = [0 0.8 591.5]';    

% 질량관성모멘트
I = []; 
I(:, :, 1) = [1.4957303e+06 0.0000000e+00 0.0000000e+00;
              0.0000000e+00 4.5009641e+05 -1.0959043e+04;
              0.0000000e+00 -1.0959043e+04 1.4874997e+06];
  
I(:, :, 2) = [1.0627201e+07 1.2357497e+04 -1.2920605e+06;
              1.2357497e+04 1.0014640e+07 1.5798255e+05;
              -1.2920605e+06 1.5798255e+05 1.9568681e+06];

I(:, :, 3) = [3.1318491e+06 -6.0760429e+03 2.4765806e+04;
              -6.0760429e+03 2.9193915e+06 4.2823763e+04;
              2.4765806e+04 4.2823763e+04 9.2402606e+05];

I(:, :, 4) = [3.9670485e+05 -3.3867048e+00 -4.7608394e+01;
              -3.3867048e+00 2.3556702e+05 3.9098238e+03;
              -4.7608394e+01 3.9098238e+03 2.9647894e+05];

I(:, :, 5) = [4.7548066e+05 0.0000000e+00 0.0000000e+00;
              0.0000000e+00 3.9961989e+05 1.4840847e+04;
              0.0000000e+00 1.4840847e+04 1.9795791e+05];
  
%% 변수 선언
tau = [];   % [6 x 1](스칼라) 구하고자 하는 목표 : 모터 토크 
n = [];     % [3 x 6] 모터토크를 구하기 위한 외력 토크 벡터
f = [];     % [3 x 6] 외력
a = [];     % [3 x 6] 가속도
ac = [];    % [3 x 6] 링크 중심에서의 가속도
w = [];     % [3 x 6] 회전 각속도
wdot = [];  % [3 x 6] 회전 각가속도
r = [];     % [3 x 6] 조인트에서 질량중심까지 벡터,                 로봇 기구학
s = [];     % [3 x 6] 이전 조인트에서 다음 조인트까지 벡터,          로봇 기구학
z = [];     % [3 x 6] 관절 z axis 벡터, 외력토크에 곱하기 위함,     로봇 기구학

%% 실시간 궤적에서 변수 받아오기

for i = 1:step
    % 각도 
    T1 = HTMatrix(a1, alpha1, d1, q(1,i));
    T2 = HTMatrix(a2, alpha2, d2, q(2,i));
    T3 = HTMatrix(a3, alpha3, d3, q(3,i));
    T4 = HTMatrix(a4, alpha4, d4, q(4,i));
    T5 = HTMatrix(a5, alpha5, d5, q(5,i));
    T6 = HTMatrix(a6, alpha6, d6, q(6,i));

    A16 = T1 * T2 * T3 * T4 * T5 * T6;
    A15 = T1 * T2 * T3 * T4 * T5;
    A14 = T1 * T2 * T3 * T4;
    A13 = T1 * T2 * T3;
    A12 = T1 * T2;
    A11 = T1;
    
    z(:, 1) = A11(1:3, 3);
    z(:, 2) = A12(1:3, 3);
    z(:, 3) = A13(1:3, 3);
    z(:, 4) = A14(1:3, 3);
    z(:, 5) = A15(1:3, 3);
    z(:, 6) = A16(1:3, 3);
    
    %% forward equation    
    % 특정 순간에서의 로봇 변수들, j는 조인트 번호
    % i 에 0 부터 5 를 넣으면 1축부터 6축까지의 값들이 생성됨.
    w0 = [0 0 0]';
    a0 = [0 0 0]';    
    v0 = [0 0 0]';
    wdot0 = [0 0 0]';
    r0 = [0 0 0]';
    for j = 0:5
        if (j == 0)
            w(:, j+1) = w0+ z(:,j+1)*qdot(i,j+1);            
            wdot(:, j+1) = wdot0 + z(:, j+1)*q2dot(i,j+1) + cross(w0, z(:, j+1)*qdot(i,j+1));
            a(:, j+1)    = a0 + cross(wdot0, s(:, j)) + cross(w0, cross(w0, s(:, j)))
            ac(:, j+1)   = a(:, j+1) + cross(w(:, j+1), r0) + cross(w(:, j+1), cross(w(:, j+1), r(:, j)))
        else
            w(:, j+1)    = w(:, j) + z(:,j+1)*qdot(i,j+1);
            wdot(:, j+1) = wdot(:, j) + z(:, j+1)*q2dot(i,j+1) + cross(w(:, j), z(:, j+1)*qdot(i,j+1));
            a(:, j+1)    = a(:, j) + cross(wdot(:, j), s(:, j)) + cross(w(:, j), cross(w(:, j), s(:, j)))
            ac(:, j+1)   = a(:, j+1) + cross(w(:, j+1), r(:, j)) + cross(w(:, j+1), cross(w(:, j+1), r(:, j)))
        end
    end
    
    %% backward equation

    for j = 1:6
        f(:, j) = m(j)*ac(:, j) + f(:, j+1) + [0 0 m(j)*g]';
        n(j) = I(:,:,j)*wdot(:, j)+cross(w(:, j),I(:, :, j)*w(:, j))+n(j+1)+cross(r(j),f(:, j))+cross((s(j)-r(j)),f(:, j+1));
        tau(j) = z(:, j)' * n(j)
    end
end
```
